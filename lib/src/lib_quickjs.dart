// Copyright (c) 2024, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_field, unused_element
import 'dart:ffi' as ffi;

@ffi.Native<ffi.Pointer<JSRuntime> Function()>(symbol: 'JS_NewRuntime')
external ffi.Pointer<JSRuntime> JS_NewRuntime();

/// info lifetime must exceed that of rt
@ffi.Native<ffi.Void Function(ffi.Pointer<JSRuntime>, ffi.Pointer<ffi.Char>)>(
    symbol: 'JS_SetRuntimeInfo')
external void JS_SetRuntimeInfo(
  ffi.Pointer<JSRuntime> rt,
  ffi.Pointer<ffi.Char> info,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSRuntime>, ffi.Size)>(
    symbol: 'JS_SetMemoryLimit')
external void JS_SetMemoryLimit(
  ffi.Pointer<JSRuntime> rt,
  int limit,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSRuntime>, ffi.Size)>(
    symbol: 'JS_SetGCThreshold')
external void JS_SetGCThreshold(
  ffi.Pointer<JSRuntime> rt,
  int gc_threshold,
);

/// use 0 to disable maximum stack size check
@ffi.Native<ffi.Void Function(ffi.Pointer<JSRuntime>, ffi.Size)>(
    symbol: 'JS_SetMaxStackSize')
external void JS_SetMaxStackSize(
  ffi.Pointer<JSRuntime> rt,
  int stack_size,
);

/// should be called when changing thread to update the stack top value
/// used to check stack overflow.
@ffi.Native<ffi.Void Function(ffi.Pointer<JSRuntime>)>(
    symbol: 'JS_UpdateStackTop')
external void JS_UpdateStackTop(
  ffi.Pointer<JSRuntime> rt,
);

@ffi.Native<
    ffi.Pointer<JSRuntime> Function(ffi.Pointer<JSMallocFunctions>,
        ffi.Pointer<ffi.Void>)>(symbol: 'JS_NewRuntime2')
external ffi.Pointer<JSRuntime> JS_NewRuntime2(
  ffi.Pointer<JSMallocFunctions> mf,
  ffi.Pointer<ffi.Void> opaque,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSRuntime>)>(symbol: 'JS_FreeRuntime')
external void JS_FreeRuntime(
  ffi.Pointer<JSRuntime> rt,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<JSRuntime>)>(
    symbol: 'JS_GetRuntimeOpaque')
external ffi.Pointer<ffi.Void> JS_GetRuntimeOpaque(
  ffi.Pointer<JSRuntime> rt,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSRuntime>, ffi.Pointer<ffi.Void>)>(
    symbol: 'JS_SetRuntimeOpaque')
external void JS_SetRuntimeOpaque(
  ffi.Pointer<JSRuntime> rt,
  ffi.Pointer<ffi.Void> opaque,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<JSRuntime>, JSValue,
        ffi.Pointer<JS_MarkFunc>)>(symbol: 'JS_MarkValue')
external void JS_MarkValue(
  ffi.Pointer<JSRuntime> rt,
  JSValue val,
  ffi.Pointer<JS_MarkFunc> mark_func,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSRuntime>)>(symbol: 'JS_RunGC')
external void JS_RunGC(
  ffi.Pointer<JSRuntime> rt,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSRuntime>, JSValue)>(
    symbol: 'JS_IsLiveObject')
external int JS_IsLiveObject(
  ffi.Pointer<JSRuntime> rt,
  JSValue obj,
);

@ffi.Native<ffi.Pointer<JSContext> Function(ffi.Pointer<JSRuntime>)>(
    symbol: 'JS_NewContext')
external ffi.Pointer<JSContext> JS_NewContext(
  ffi.Pointer<JSRuntime> rt,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(symbol: 'JS_FreeContext')
external void JS_FreeContext(
  ffi.Pointer<JSContext> s,
);

@ffi.Native<ffi.Pointer<JSContext> Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_DupContext')
external ffi.Pointer<JSContext> JS_DupContext(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_GetContextOpaque')
external ffi.Pointer<ffi.Void> JS_GetContextOpaque(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Void>)>(
    symbol: 'JS_SetContextOpaque')
external void JS_SetContextOpaque(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Void> opaque,
);

@ffi.Native<ffi.Pointer<JSRuntime> Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_GetRuntime')
external ffi.Pointer<JSRuntime> JS_GetRuntime(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>, JSClassID, JSValue)>(
    symbol: 'JS_SetClassProto')
external void JS_SetClassProto(
  ffi.Pointer<JSContext> ctx,
  int class_id,
  JSValue obj,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, JSClassID)>(
    symbol: 'JS_GetClassProto')
external JSValue JS_GetClassProto(
  ffi.Pointer<JSContext> ctx,
  int class_id,
);

/// the following functions are used to select the intrinsic object to
/// save memory
@ffi.Native<ffi.Pointer<JSContext> Function(ffi.Pointer<JSRuntime>)>(
    symbol: 'JS_NewContextRaw')
external ffi.Pointer<JSContext> JS_NewContextRaw(
  ffi.Pointer<JSRuntime> rt,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicBaseObjects')
external void JS_AddIntrinsicBaseObjects(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicDate')
external void JS_AddIntrinsicDate(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicEval')
external void JS_AddIntrinsicEval(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicStringNormalize')
external void JS_AddIntrinsicStringNormalize(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicRegExpCompiler')
external void JS_AddIntrinsicRegExpCompiler(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicRegExp')
external void JS_AddIntrinsicRegExp(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicJSON')
external void JS_AddIntrinsicJSON(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicProxy')
external void JS_AddIntrinsicProxy(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicMapSet')
external void JS_AddIntrinsicMapSet(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicTypedArrays')
external void JS_AddIntrinsicTypedArrays(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicPromise')
external void JS_AddIntrinsicPromise(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicBigInt')
external void JS_AddIntrinsicBigInt(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicBigFloat')
external void JS_AddIntrinsicBigFloat(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicBigDecimal')
external void JS_AddIntrinsicBigDecimal(
  ffi.Pointer<JSContext> ctx,
);

/// enable operator overloading
@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_AddIntrinsicOperators')
external void JS_AddIntrinsicOperators(
  ffi.Pointer<JSContext> ctx,
);

/// enable "use math"
@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>, ffi.Int)>(
    symbol: 'JS_EnableBignumExt')
external void JS_EnableBignumExt(
  ffi.Pointer<JSContext> ctx,
  int enable,
);

@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, JSValue, ffi.Int,
        ffi.Pointer<JSValue>)>(symbol: 'js_string_codePointRange')
external JSValue js_string_codePointRange(
  ffi.Pointer<JSContext> ctx,
  JSValue this_val,
  int argc,
  ffi.Pointer<JSValue> argv,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<JSRuntime>, ffi.Size)>(
    symbol: 'js_malloc_rt')
external ffi.Pointer<ffi.Void> js_malloc_rt(
  ffi.Pointer<JSRuntime> rt,
  int size,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSRuntime>, ffi.Pointer<ffi.Void>)>(
    symbol: 'js_free_rt')
external void js_free_rt(
  ffi.Pointer<JSRuntime> rt,
  ffi.Pointer<ffi.Void> ptr,
);

@ffi.Native<
    ffi.Pointer<ffi.Void> Function(ffi.Pointer<JSRuntime>,
        ffi.Pointer<ffi.Void>, ffi.Size)>(symbol: 'js_realloc_rt')
external ffi.Pointer<ffi.Void> js_realloc_rt(
  ffi.Pointer<JSRuntime> rt,
  ffi.Pointer<ffi.Void> ptr,
  int size,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<JSRuntime>, ffi.Pointer<ffi.Void>)>(
    symbol: 'js_malloc_usable_size_rt')
external int js_malloc_usable_size_rt(
  ffi.Pointer<JSRuntime> rt,
  ffi.Pointer<ffi.Void> ptr,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<JSRuntime>, ffi.Size)>(
    symbol: 'js_mallocz_rt')
external ffi.Pointer<ffi.Void> js_mallocz_rt(
  ffi.Pointer<JSRuntime> rt,
  int size,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<JSContext>, ffi.Size)>(
    symbol: 'js_malloc')
external ffi.Pointer<ffi.Void> js_malloc(
  ffi.Pointer<JSContext> ctx,
  int size,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Void>)>(
    symbol: 'js_free')
external void js_free(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Void> ptr,
);

@ffi.Native<
    ffi.Pointer<ffi.Void> Function(ffi.Pointer<JSContext>,
        ffi.Pointer<ffi.Void>, ffi.Size)>(symbol: 'js_realloc')
external ffi.Pointer<ffi.Void> js_realloc(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Void> ptr,
  int size,
);

@ffi.Native<ffi.Size Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Void>)>(
    symbol: 'js_malloc_usable_size')
external int js_malloc_usable_size(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Void> ptr,
);

@ffi.Native<
    ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<JSContext>,
        ffi.Pointer<ffi.Void>,
        ffi.Size,
        ffi.Pointer<ffi.Size>)>(symbol: 'js_realloc2')
external ffi.Pointer<ffi.Void> js_realloc2(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Void> ptr,
  int size,
  ffi.Pointer<ffi.Size> pslack,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(ffi.Pointer<JSContext>, ffi.Size)>(
    symbol: 'js_mallocz')
external ffi.Pointer<ffi.Void> js_mallocz(
  ffi.Pointer<JSContext> ctx,
  int size,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>)>(symbol: 'js_strdup')
external ffi.Pointer<ffi.Char> js_strdup(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> str,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(ffi.Pointer<JSContext>,
        ffi.Pointer<ffi.Char>, ffi.Size)>(symbol: 'js_strndup')
external ffi.Pointer<ffi.Char> js_strndup(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> s,
  int n,
);

@ffi.Native<
        ffi.Void Function(ffi.Pointer<JSRuntime>, ffi.Pointer<JSMemoryUsage>)>(
    symbol: 'JS_ComputeMemoryUsage')
external void JS_ComputeMemoryUsage(
  ffi.Pointer<JSRuntime> rt,
  ffi.Pointer<JSMemoryUsage> s,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<FILE>, ffi.Pointer<JSMemoryUsage>,
        ffi.Pointer<JSRuntime>)>(symbol: 'JS_DumpMemoryUsage')
external void JS_DumpMemoryUsage(
  ffi.Pointer<FILE> fp,
  ffi.Pointer<JSMemoryUsage> s,
  ffi.Pointer<JSRuntime> rt,
);

@ffi.Native<
    JSAtom Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>,
        ffi.Size)>(symbol: 'JS_NewAtomLen')
external int JS_NewAtomLen(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> str,
  int len,
);

@ffi.Native<JSAtom Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>)>(
    symbol: 'JS_NewAtom')
external int JS_NewAtom(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> str,
);

@ffi.Native<JSAtom Function(ffi.Pointer<JSContext>, ffi.Uint32)>(
    symbol: 'JS_NewAtomUInt32')
external int JS_NewAtomUInt32(
  ffi.Pointer<JSContext> ctx,
  int n,
);

@ffi.Native<JSAtom Function(ffi.Pointer<JSContext>, JSAtom)>(
    symbol: 'JS_DupAtom')
external int JS_DupAtom(
  ffi.Pointer<JSContext> ctx,
  int v,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>, JSAtom)>(
    symbol: 'JS_FreeAtom')
external void JS_FreeAtom(
  ffi.Pointer<JSContext> ctx,
  int v,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSRuntime>, JSAtom)>(
    symbol: 'JS_FreeAtomRT')
external void JS_FreeAtomRT(
  ffi.Pointer<JSRuntime> rt,
  int v,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, JSAtom)>(
    symbol: 'JS_AtomToValue')
external JSValue JS_AtomToValue(
  ffi.Pointer<JSContext> ctx,
  int atom,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, JSAtom)>(
    symbol: 'JS_AtomToString')
external JSValue JS_AtomToString(
  ffi.Pointer<JSContext> ctx,
  int atom,
);

@ffi.Native<ffi.Pointer<ffi.Char> Function(ffi.Pointer<JSContext>, JSAtom)>(
    symbol: 'JS_AtomToCString')
external ffi.Pointer<ffi.Char> JS_AtomToCString(
  ffi.Pointer<JSContext> ctx,
  int atom,
);

@ffi.Native<JSAtom Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_ValueToAtom')
external int JS_ValueToAtom(
  ffi.Pointer<JSContext> ctx,
  JSValue val,
);

@ffi.Native<JSClassID Function(ffi.Pointer<JSClassID>)>(symbol: 'JS_NewClassID')
external int JS_NewClassID(
  ffi.Pointer<JSClassID> pclass_id,
);

/// Returns the class ID if `v` is an object, otherwise returns JS_INVALID_CLASS_ID.
@ffi.Native<JSClassID Function(JSValue)>(symbol: 'JS_GetClassID')
external int JS_GetClassID(
  JSValue v,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSRuntime>, JSClassID,
        ffi.Pointer<JSClassDef>)>(symbol: 'JS_NewClass')
external int JS_NewClass(
  ffi.Pointer<JSRuntime> rt,
  int class_id,
  ffi.Pointer<JSClassDef> class_def,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSRuntime>, JSClassID)>(
    symbol: 'JS_IsRegisteredClass')
external int JS_IsRegisteredClass(
  ffi.Pointer<JSRuntime> rt,
  int class_id,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, ffi.Int64)>(
    symbol: 'JS_NewBigInt64')
external JSValue JS_NewBigInt64(
  ffi.Pointer<JSContext> ctx,
  int v,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, ffi.Uint64)>(
    symbol: 'JS_NewBigUint64')
external JSValue JS_NewBigUint64(
  ffi.Pointer<JSContext> ctx,
  int v,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_Throw')
external JSValue JS_Throw(
  ffi.Pointer<JSContext> ctx,
  JSValue obj,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>)>(symbol: 'JS_GetException')
external JSValue JS_GetException(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_IsError')
external int JS_IsError(
  ffi.Pointer<JSContext> ctx,
  JSValue val,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_ResetUncatchableError')
external void JS_ResetUncatchableError(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>)>(symbol: 'JS_NewError')
external JSValue JS_NewError(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>)>(
    symbol: 'JS_ThrowSyntaxError')
external JSValue JS_ThrowSyntaxError(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> fmt,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>)>(
    symbol: 'JS_ThrowTypeError')
external JSValue JS_ThrowTypeError(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> fmt,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>)>(
    symbol: 'JS_ThrowReferenceError')
external JSValue JS_ThrowReferenceError(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> fmt,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>)>(
    symbol: 'JS_ThrowRangeError')
external JSValue JS_ThrowRangeError(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> fmt,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>)>(
    symbol: 'JS_ThrowInternalError')
external JSValue JS_ThrowInternalError(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> fmt,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_ThrowOutOfMemory')
external JSValue JS_ThrowOutOfMemory(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: '__JS_FreeValue')
external void ffi__JS_FreeValue(
  ffi.Pointer<JSContext> ctx,
  JSValue v,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSRuntime>, JSValue)>(
    symbol: '__JS_FreeValueRT')
external void ffi__JS_FreeValueRT(
  ffi.Pointer<JSRuntime> rt,
  JSValue v,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_ToBool')
external int JS_ToBool(
  ffi.Pointer<JSContext> ctx,
  JSValue val,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Int32>,
        JSValue)>(symbol: 'JS_ToInt32')
external int JS_ToInt32(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Int32> pres,
  JSValue val,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Int64>,
        JSValue)>(symbol: 'JS_ToInt64')
external int JS_ToInt64(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Int64> pres,
  JSValue val,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Uint64>,
        JSValue)>(symbol: 'JS_ToIndex')
external int JS_ToIndex(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Uint64> plen,
  JSValue val,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Double>,
        JSValue)>(symbol: 'JS_ToFloat64')
external int JS_ToFloat64(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Double> pres,
  JSValue val,
);

/// return an exception if 'val' is a Number
@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Int64>,
        JSValue)>(symbol: 'JS_ToBigInt64')
external int JS_ToBigInt64(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Int64> pres,
  JSValue val,
);

/// same as JS_ToInt64() but allow BigInt
@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Int64>,
        JSValue)>(symbol: 'JS_ToInt64Ext')
external int JS_ToInt64Ext(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Int64> pres,
  JSValue val,
);

@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>,
        ffi.Size)>(symbol: 'JS_NewStringLen')
external JSValue JS_NewStringLen(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> str1,
  int len1,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>)>(
    symbol: 'JS_NewString')
external JSValue JS_NewString(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> str,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>)>(
    symbol: 'JS_NewAtomString')
external JSValue JS_NewAtomString(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> str,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_ToString')
external JSValue JS_ToString(
  ffi.Pointer<JSContext> ctx,
  JSValue val,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_ToPropertyKey')
external JSValue JS_ToPropertyKey(
  ffi.Pointer<JSContext> ctx,
  JSValue val,
);

@ffi.Native<
    ffi.Pointer<ffi.Char> Function(ffi.Pointer<JSContext>,
        ffi.Pointer<ffi.Size>, JSValue, ffi.Int)>(symbol: 'JS_ToCStringLen2')
external ffi.Pointer<ffi.Char> JS_ToCStringLen2(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Size> plen,
  JSValue val1,
  int cesu8,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>)>(
    symbol: 'JS_FreeCString')
external void JS_FreeCString(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> ptr,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, JSValue, JSClassID)>(
    symbol: 'JS_NewObjectProtoClass')
external JSValue JS_NewObjectProtoClass(
  ffi.Pointer<JSContext> ctx,
  JSValue proto,
  int class_id,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, ffi.Int)>(
    symbol: 'JS_NewObjectClass')
external JSValue JS_NewObjectClass(
  ffi.Pointer<JSContext> ctx,
  int class_id,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_NewObjectProto')
external JSValue JS_NewObjectProto(
  ffi.Pointer<JSContext> ctx,
  JSValue proto,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>)>(symbol: 'JS_NewObject')
external JSValue JS_NewObject(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_IsFunction')
external int JS_IsFunction(
  ffi.Pointer<JSContext> ctx,
  JSValue val,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_IsConstructor')
external int JS_IsConstructor(
  ffi.Pointer<JSContext> ctx,
  JSValue val,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSContext>, JSValue, ffi.Int)>(
    symbol: 'JS_SetConstructorBit')
external int JS_SetConstructorBit(
  ffi.Pointer<JSContext> ctx,
  JSValue func_obj,
  int val,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>)>(symbol: 'JS_NewArray')
external JSValue JS_NewArray(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_IsArray')
external int JS_IsArray(
  ffi.Pointer<JSContext> ctx,
  JSValue val,
);

@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, JSValue, JSAtom, JSValue,
        ffi.Int)>(symbol: 'JS_GetPropertyInternal')
external JSValue JS_GetPropertyInternal(
  ffi.Pointer<JSContext> ctx,
  JSValue obj,
  int prop,
  JSValue receiver,
  int throw_ref_error,
);

@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, JSValue,
        ffi.Pointer<ffi.Char>)>(symbol: 'JS_GetPropertyStr')
external JSValue JS_GetPropertyStr(
  ffi.Pointer<JSContext> ctx,
  JSValue this_obj,
  ffi.Pointer<ffi.Char> prop,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, JSValue, ffi.Uint32)>(
    symbol: 'JS_GetPropertyUint32')
external JSValue JS_GetPropertyUint32(
  ffi.Pointer<JSContext> ctx,
  JSValue this_obj,
  int idx,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, JSValue, JSAtom, JSValue, JSValue,
        ffi.Int)>(symbol: 'JS_SetPropertyInternal')
external int JS_SetPropertyInternal(
  ffi.Pointer<JSContext> ctx,
  JSValue obj,
  int prop,
  JSValue val,
  JSValue this_obj,
  int flags,
);

@ffi.Native<
        ffi.Int Function(ffi.Pointer<JSContext>, JSValue, ffi.Uint32, JSValue)>(
    symbol: 'JS_SetPropertyUint32')
external int JS_SetPropertyUint32(
  ffi.Pointer<JSContext> ctx,
  JSValue this_obj,
  int idx,
  JSValue val,
);

@ffi.Native<
        ffi.Int Function(ffi.Pointer<JSContext>, JSValue, ffi.Int64, JSValue)>(
    symbol: 'JS_SetPropertyInt64')
external int JS_SetPropertyInt64(
  ffi.Pointer<JSContext> ctx,
  JSValue this_obj,
  int idx,
  JSValue val,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, JSValue, ffi.Pointer<ffi.Char>,
        JSValue)>(symbol: 'JS_SetPropertyStr')
external int JS_SetPropertyStr(
  ffi.Pointer<JSContext> ctx,
  JSValue this_obj,
  ffi.Pointer<ffi.Char> prop,
  JSValue val,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSContext>, JSValue, JSAtom)>(
    symbol: 'JS_HasProperty')
external int JS_HasProperty(
  ffi.Pointer<JSContext> ctx,
  JSValue this_obj,
  int prop,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_IsExtensible')
external int JS_IsExtensible(
  ffi.Pointer<JSContext> ctx,
  JSValue obj,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_PreventExtensions')
external int JS_PreventExtensions(
  ffi.Pointer<JSContext> ctx,
  JSValue obj,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSContext>, JSValue, JSAtom, ffi.Int)>(
    symbol: 'JS_DeleteProperty')
external int JS_DeleteProperty(
  ffi.Pointer<JSContext> ctx,
  JSValue obj,
  int prop,
  int flags,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSContext>, JSValue, JSValue)>(
    symbol: 'JS_SetPrototype')
external int JS_SetPrototype(
  ffi.Pointer<JSContext> ctx,
  JSValue obj,
  JSValue proto_val,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_GetPrototype')
external JSValue JS_GetPrototype(
  ffi.Pointer<JSContext> ctx,
  JSValue val,
);

@ffi.Native<
    ffi.Int Function(
        ffi.Pointer<JSContext>,
        ffi.Pointer<ffi.Pointer<JSPropertyEnum>>,
        ffi.Pointer<ffi.Uint32>,
        JSValue,
        ffi.Int)>(symbol: 'JS_GetOwnPropertyNames')
external int JS_GetOwnPropertyNames(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Pointer<JSPropertyEnum>> ptab,
  ffi.Pointer<ffi.Uint32> plen,
  JSValue obj,
  int flags,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, ffi.Pointer<JSPropertyDescriptor>,
        JSValue, JSAtom)>(symbol: 'JS_GetOwnProperty')
external int JS_GetOwnProperty(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<JSPropertyDescriptor> desc,
  JSValue obj,
  int prop,
);

@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, JSValue, JSValue, ffi.Int,
        ffi.Pointer<JSValue>)>(symbol: 'JS_Call')
external JSValue JS_Call(
  ffi.Pointer<JSContext> ctx,
  JSValue func_obj,
  JSValue this_obj,
  int argc,
  ffi.Pointer<JSValue> argv,
);

@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, JSValue, JSAtom, ffi.Int,
        ffi.Pointer<JSValue>)>(symbol: 'JS_Invoke')
external JSValue JS_Invoke(
  ffi.Pointer<JSContext> ctx,
  JSValue this_val,
  int atom,
  int argc,
  ffi.Pointer<JSValue> argv,
);

@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, JSValue, ffi.Int,
        ffi.Pointer<JSValue>)>(symbol: 'JS_CallConstructor')
external JSValue JS_CallConstructor(
  ffi.Pointer<JSContext> ctx,
  JSValue func_obj,
  int argc,
  ffi.Pointer<JSValue> argv,
);

@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, JSValue, JSValue, ffi.Int,
        ffi.Pointer<JSValue>)>(symbol: 'JS_CallConstructor2')
external JSValue JS_CallConstructor2(
  ffi.Pointer<JSContext> ctx,
  JSValue func_obj,
  JSValue new_target,
  int argc,
  ffi.Pointer<JSValue> argv,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>(
    symbol: 'JS_DetectModule')
external int JS_DetectModule(
  ffi.Pointer<ffi.Char> input,
  int input_len,
);

/// 'input' must be zero terminated i.e. input[input_len] = '\0'.
@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>, ffi.Size,
        ffi.Pointer<ffi.Char>, ffi.Int)>(symbol: 'JS_Eval')
external JSValue JS_Eval(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> input,
  int input_len,
  ffi.Pointer<ffi.Char> filename,
  int eval_flags,
);

/// same as JS_Eval() but with an explicit 'this_obj' parameter
@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, JSValue, ffi.Pointer<ffi.Char>,
        ffi.Size, ffi.Pointer<ffi.Char>, ffi.Int)>(symbol: 'JS_EvalThis')
external JSValue JS_EvalThis(
  ffi.Pointer<JSContext> ctx,
  JSValue this_obj,
  ffi.Pointer<ffi.Char> input,
  int input_len,
  ffi.Pointer<ffi.Char> filename,
  int eval_flags,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>)>(
    symbol: 'JS_GetGlobalObject')
external JSValue JS_GetGlobalObject(
  ffi.Pointer<JSContext> ctx,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSContext>, JSValue, JSValue)>(
    symbol: 'JS_IsInstanceOf')
external int JS_IsInstanceOf(
  ffi.Pointer<JSContext> ctx,
  JSValue val,
  JSValue obj,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, JSValue, JSAtom, JSValue, JSValue,
        JSValue, ffi.Int)>(symbol: 'JS_DefineProperty')
external int JS_DefineProperty(
  ffi.Pointer<JSContext> ctx,
  JSValue this_obj,
  int prop,
  JSValue val,
  JSValue getter,
  JSValue setter,
  int flags,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, JSValue, JSAtom, JSValue,
        ffi.Int)>(symbol: 'JS_DefinePropertyValue')
external int JS_DefinePropertyValue(
  ffi.Pointer<JSContext> ctx,
  JSValue this_obj,
  int prop,
  JSValue val,
  int flags,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, JSValue, ffi.Uint32, JSValue,
        ffi.Int)>(symbol: 'JS_DefinePropertyValueUint32')
external int JS_DefinePropertyValueUint32(
  ffi.Pointer<JSContext> ctx,
  JSValue this_obj,
  int idx,
  JSValue val,
  int flags,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, JSValue, ffi.Pointer<ffi.Char>,
        JSValue, ffi.Int)>(symbol: 'JS_DefinePropertyValueStr')
external int JS_DefinePropertyValueStr(
  ffi.Pointer<JSContext> ctx,
  JSValue this_obj,
  ffi.Pointer<ffi.Char> prop,
  JSValue val,
  int flags,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, JSValue, JSAtom, JSValue, JSValue,
        ffi.Int)>(symbol: 'JS_DefinePropertyGetSet')
external int JS_DefinePropertyGetSet(
  ffi.Pointer<JSContext> ctx,
  JSValue this_obj,
  int prop,
  JSValue getter,
  JSValue setter,
  int flags,
);

@ffi.Native<ffi.Void Function(JSValue, ffi.Pointer<ffi.Void>)>(
    symbol: 'JS_SetOpaque')
external void JS_SetOpaque(
  JSValue obj,
  ffi.Pointer<ffi.Void> opaque,
);

@ffi.Native<ffi.Pointer<ffi.Void> Function(JSValue, JSClassID)>(
    symbol: 'JS_GetOpaque')
external ffi.Pointer<ffi.Void> JS_GetOpaque(
  JSValue obj,
  int class_id,
);

@ffi.Native<
    ffi.Pointer<ffi.Void> Function(
        ffi.Pointer<JSContext>, JSValue, JSClassID)>(symbol: 'JS_GetOpaque2')
external ffi.Pointer<ffi.Void> JS_GetOpaque2(
  ffi.Pointer<JSContext> ctx,
  JSValue obj,
  int class_id,
);

/// 'buf' must be zero terminated i.e. buf[buf_len] = '\0'.
@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>, ffi.Size,
        ffi.Pointer<ffi.Char>)>(symbol: 'JS_ParseJSON')
external JSValue JS_ParseJSON(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> buf,
  int buf_len,
  ffi.Pointer<ffi.Char> filename,
);

@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>, ffi.Size,
        ffi.Pointer<ffi.Char>, ffi.Int)>(symbol: 'JS_ParseJSON2')
external JSValue JS_ParseJSON2(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> buf,
  int buf_len,
  ffi.Pointer<ffi.Char> filename,
  int flags,
);

@ffi.Native<
        JSValue Function(ffi.Pointer<JSContext>, JSValue, JSValue, JSValue)>(
    symbol: 'JS_JSONStringify')
external JSValue JS_JSONStringify(
  ffi.Pointer<JSContext> ctx,
  JSValue obj,
  JSValue replacer,
  JSValue space0,
);

@ffi.Native<
    JSValue Function(
        ffi.Pointer<JSContext>,
        ffi.Pointer<ffi.Uint8>,
        ffi.Size,
        ffi.Pointer<JSFreeArrayBufferDataFunc>,
        ffi.Pointer<ffi.Void>,
        ffi.Int)>(symbol: 'JS_NewArrayBuffer')
external JSValue JS_NewArrayBuffer(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Uint8> buf,
  int len,
  ffi.Pointer<JSFreeArrayBufferDataFunc> free_func,
  ffi.Pointer<ffi.Void> opaque,
  int is_shared,
);

@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Uint8>,
        ffi.Size)>(symbol: 'JS_NewArrayBufferCopy')
external JSValue JS_NewArrayBufferCopy(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Uint8> buf,
  int len,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_DetachArrayBuffer')
external void JS_DetachArrayBuffer(
  ffi.Pointer<JSContext> ctx,
  JSValue obj,
);

@ffi.Native<
    ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<JSContext>,
        ffi.Pointer<ffi.Size>, JSValue)>(symbol: 'JS_GetArrayBuffer')
external ffi.Pointer<ffi.Uint8> JS_GetArrayBuffer(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Size> psize,
  JSValue obj,
);

@ffi.Native<
    JSValue Function(
        ffi.Pointer<JSContext>,
        JSValue,
        ffi.Pointer<ffi.Size>,
        ffi.Pointer<ffi.Size>,
        ffi.Pointer<ffi.Size>)>(symbol: 'JS_GetTypedArrayBuffer')
external JSValue JS_GetTypedArrayBuffer(
  ffi.Pointer<JSContext> ctx,
  JSValue obj,
  ffi.Pointer<ffi.Size> pbyte_offset,
  ffi.Pointer<ffi.Size> pbyte_length,
  ffi.Pointer<ffi.Size> pbytes_per_element,
);

@ffi.Native<
        ffi.Void Function(
            ffi.Pointer<JSRuntime>, ffi.Pointer<JSSharedArrayBufferFunctions>)>(
    symbol: 'JS_SetSharedArrayBufferFunctions')
external void JS_SetSharedArrayBufferFunctions(
  ffi.Pointer<JSRuntime> rt,
  ffi.Pointer<JSSharedArrayBufferFunctions> sf,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<JSValue>)>(
    symbol: 'JS_NewPromiseCapability')
external JSValue JS_NewPromiseCapability(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<JSValue> resolving_funcs,
);

@ffi.Native<ffi.Int32 Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_PromiseState')
external int JS_PromiseState(
  ffi.Pointer<JSContext> ctx,
  JSValue promise,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_PromiseResult')
external JSValue JS_PromiseResult(
  ffi.Pointer<JSContext> ctx,
  JSValue promise,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<JSRuntime>,
        ffi.Pointer<JSHostPromiseRejectionTracker>,
        ffi.Pointer<ffi.Void>)>(symbol: 'JS_SetHostPromiseRejectionTracker')
external void JS_SetHostPromiseRejectionTracker(
  ffi.Pointer<JSRuntime> rt,
  ffi.Pointer<JSHostPromiseRejectionTracker> cb,
  ffi.Pointer<ffi.Void> opaque,
);

@ffi.Native<
    ffi.Void Function(ffi.Pointer<JSRuntime>, ffi.Pointer<JSInterruptHandler>,
        ffi.Pointer<ffi.Void>)>(symbol: 'JS_SetInterruptHandler')
external void JS_SetInterruptHandler(
  ffi.Pointer<JSRuntime> rt,
  ffi.Pointer<JSInterruptHandler> cb,
  ffi.Pointer<ffi.Void> opaque,
);

/// if can_block is TRUE, Atomics.wait() can be used
@ffi.Native<ffi.Void Function(ffi.Pointer<JSRuntime>, ffi.Int)>(
    symbol: 'JS_SetCanBlock')
external void JS_SetCanBlock(
  ffi.Pointer<JSRuntime> rt,
  int can_block,
);

/// set the [IsHTMLDDA] internal slot
@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_SetIsHTMLDDA')
external void JS_SetIsHTMLDDA(
  ffi.Pointer<JSContext> ctx,
  JSValue obj,
);

/// module_normalize = NULL is allowed and invokes the default module
/// filename normalizer
@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<JSRuntime>,
        ffi.Pointer<JSModuleNormalizeFunc>,
        ffi.Pointer<JSModuleLoaderFunc>,
        ffi.Pointer<ffi.Void>)>(symbol: 'JS_SetModuleLoaderFunc')
external void JS_SetModuleLoaderFunc(
  ffi.Pointer<JSRuntime> rt,
  ffi.Pointer<JSModuleNormalizeFunc> module_normalize,
  ffi.Pointer<JSModuleLoaderFunc> module_loader,
  ffi.Pointer<ffi.Void> opaque,
);

/// return the import.meta object of a module
@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<JSModuleDef>)>(
    symbol: 'JS_GetImportMeta')
external JSValue JS_GetImportMeta(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<JSModuleDef> m,
);

@ffi.Native<JSAtom Function(ffi.Pointer<JSContext>, ffi.Pointer<JSModuleDef>)>(
    symbol: 'JS_GetModuleName')
external int JS_GetModuleName(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<JSModuleDef> m,
);

@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<JSModuleDef>)>(
    symbol: 'JS_GetModuleNamespace')
external JSValue JS_GetModuleNamespace(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<JSModuleDef> m,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, ffi.Pointer<JSJobFunc>, ffi.Int,
        ffi.Pointer<JSValue>)>(symbol: 'JS_EnqueueJob')
external int JS_EnqueueJob(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<JSJobFunc> job_func,
  int argc,
  ffi.Pointer<JSValue> argv,
);

@ffi.Native<ffi.Int Function(ffi.Pointer<JSRuntime>)>(symbol: 'JS_IsJobPending')
external int JS_IsJobPending(
  ffi.Pointer<JSRuntime> rt,
);

@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSRuntime>,
        ffi.Pointer<ffi.Pointer<JSContext>>)>(symbol: 'JS_ExecutePendingJob')
external int JS_ExecutePendingJob(
  ffi.Pointer<JSRuntime> rt,
  ffi.Pointer<ffi.Pointer<JSContext>> pctx,
);

@ffi.Native<
    ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<JSContext>,
        ffi.Pointer<ffi.Size>, JSValue, ffi.Int)>(symbol: 'JS_WriteObject')
external ffi.Pointer<ffi.Uint8> JS_WriteObject(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Size> psize,
  JSValue obj,
  int flags,
);

@ffi.Native<
    ffi.Pointer<ffi.Uint8> Function(
        ffi.Pointer<JSContext>,
        ffi.Pointer<ffi.Size>,
        JSValue,
        ffi.Int,
        ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Uint8>>>,
        ffi.Pointer<ffi.Size>)>(symbol: 'JS_WriteObject2')
external ffi.Pointer<ffi.Uint8> JS_WriteObject2(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Size> psize,
  JSValue obj,
  int flags,
  ffi.Pointer<ffi.Pointer<ffi.Pointer<ffi.Uint8>>> psab_tab,
  ffi.Pointer<ffi.Size> psab_tab_len,
);

@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Uint8>, ffi.Size,
        ffi.Int)>(symbol: 'JS_ReadObject')
external JSValue JS_ReadObject(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Uint8> buf,
  int buf_len,
  int flags,
);

/// instantiate and evaluate a bytecode function. Only used when
/// reading a script or module with JS_ReadObject()
@ffi.Native<JSValue Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_EvalFunction')
external JSValue JS_EvalFunction(
  ffi.Pointer<JSContext> ctx,
  JSValue fun_obj,
);

/// load the dependencies of the module 'obj'. Useful when JS_ReadObject()
/// returns a module.
@ffi.Native<ffi.Int Function(ffi.Pointer<JSContext>, JSValue)>(
    symbol: 'JS_ResolveModule')
external int JS_ResolveModule(
  ffi.Pointer<JSContext> ctx,
  JSValue obj,
);

/// only exported for os.Worker()
@ffi.Native<JSAtom Function(ffi.Pointer<JSContext>, ffi.Int)>(
    symbol: 'JS_GetScriptOrModuleName')
external int JS_GetScriptOrModuleName(
  ffi.Pointer<JSContext> ctx,
  int n_stack_levels,
);

/// only exported for os.Worker()
@ffi.Native<
    JSValue Function(ffi.Pointer<JSContext>, ffi.Pointer<ffi.Char>,
        ffi.Pointer<ffi.Char>)>(symbol: 'JS_LoadModule')
external JSValue JS_LoadModule(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> basename,
  ffi.Pointer<ffi.Char> filename,
);

@ffi.Native<
    JSValue Function(
        ffi.Pointer<JSContext>,
        ffi.Pointer<JSCFunction>,
        ffi.Pointer<ffi.Char>,
        ffi.Int,
        ffi.Int32,
        ffi.Int)>(symbol: 'JS_NewCFunction2')
external JSValue JS_NewCFunction2(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<JSCFunction> func,
  ffi.Pointer<ffi.Char> name,
  int length,
  int cproto,
  int magic,
);

@ffi.Native<
    JSValue Function(
        ffi.Pointer<JSContext>,
        ffi.Pointer<JSCFunctionData>,
        ffi.Int,
        ffi.Int,
        ffi.Int,
        ffi.Pointer<JSValue>)>(symbol: 'JS_NewCFunctionData')
external JSValue JS_NewCFunctionData(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<JSCFunctionData> func,
  int length,
  int magic,
  int data_len,
  ffi.Pointer<JSValue> data,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<JSContext>, JSValue, JSValue)>(
    symbol: 'JS_SetConstructor')
external void JS_SetConstructor(
  ffi.Pointer<JSContext> ctx,
  JSValue func_obj,
  JSValue proto,
);

@ffi.Native<
    ffi.Void Function(
        ffi.Pointer<JSContext>,
        JSValue,
        ffi.Pointer<JSCFunctionListEntry>,
        ffi.Int)>(symbol: 'JS_SetPropertyFunctionList')
external void JS_SetPropertyFunctionList(
  ffi.Pointer<JSContext> ctx,
  JSValue obj,
  ffi.Pointer<JSCFunctionListEntry> tab,
  int len,
);

@ffi.Native<
    ffi.Pointer<JSModuleDef> Function(
        ffi.Pointer<JSContext>,
        ffi.Pointer<ffi.Char>,
        ffi.Pointer<JSModuleInitFunc>)>(symbol: 'JS_NewCModule')
external ffi.Pointer<JSModuleDef> JS_NewCModule(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<ffi.Char> name_str,
  ffi.Pointer<JSModuleInitFunc> func,
);

/// can only be called before the module is instantiated
@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, ffi.Pointer<JSModuleDef>,
        ffi.Pointer<ffi.Char>)>(symbol: 'JS_AddModuleExport')
external int JS_AddModuleExport(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<JSModuleDef> m,
  ffi.Pointer<ffi.Char> name_str,
);

@ffi.Native<
    ffi.Int Function(
        ffi.Pointer<JSContext>,
        ffi.Pointer<JSModuleDef>,
        ffi.Pointer<JSCFunctionListEntry>,
        ffi.Int)>(symbol: 'JS_AddModuleExportList')
external int JS_AddModuleExportList(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<JSModuleDef> m,
  ffi.Pointer<JSCFunctionListEntry> tab,
  int len,
);

/// can only be called after the module is instantiated
@ffi.Native<
    ffi.Int Function(ffi.Pointer<JSContext>, ffi.Pointer<JSModuleDef>,
        ffi.Pointer<ffi.Char>, JSValue)>(symbol: 'JS_SetModuleExport')
external int JS_SetModuleExport(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<JSModuleDef> m,
  ffi.Pointer<ffi.Char> export_name,
  JSValue val,
);

@ffi.Native<
    ffi.Int Function(
        ffi.Pointer<JSContext>,
        ffi.Pointer<JSModuleDef>,
        ffi.Pointer<JSCFunctionListEntry>,
        ffi.Int)>(symbol: 'JS_SetModuleExportList')
external int JS_SetModuleExportList(
  ffi.Pointer<JSContext> ctx,
  ffi.Pointer<JSModuleDef> m,
  ffi.Pointer<JSCFunctionListEntry> tab,
  int len,
);

final class JSRuntime extends ffi.Opaque {}

final class JSContext extends ffi.Opaque {}

final class JSObject extends ffi.Opaque {}

final class JSClass extends ffi.Opaque {}

final class JSRefCountHeader extends ffi.Struct {
  @ffi.Int()
  external int ref_count;
}

final class JSValueUnion extends ffi.Union {
  @ffi.Int32()
  external int int32;

  @ffi.Double()
  external double float64;

  external ffi.Pointer<ffi.Void> ptr;
}

final class JSValue extends ffi.Struct {
  external JSValueUnion u;

  @ffi.Int64()
  external int tag;
}

final class JSMallocState extends ffi.Struct {
  @ffi.Size()
  external int malloc_count;

  @ffi.Size()
  external int malloc_size;

  @ffi.Size()
  external int malloc_limit;

  /// user opaque
  external ffi.Pointer<ffi.Void> opaque;
}

final class JSMallocFunctions extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<JSMallocState> s, ffi.Size size)>> js_malloc;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<JSMallocState> s, ffi.Pointer<ffi.Void> ptr)>>
      js_free;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<JSMallocState> s,
              ffi.Pointer<ffi.Void> ptr, ffi.Size size)>> js_realloc;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<ffi.Void> ptr)>>
      js_malloc_usable_size;
}

final class JSGCObjectHeader extends ffi.Opaque {}

typedef JS_MarkFunc = ffi.NativeFunction<
    ffi.Void Function(
        ffi.Pointer<JSRuntime> rt, ffi.Pointer<JSGCObjectHeader> gp)>;
typedef JSClassID = ffi.Uint32;
typedef DartJSClassID = int;

final class JSMemoryUsage extends ffi.Struct {
  @ffi.Int64()
  external int malloc_size;

  @ffi.Int64()
  external int malloc_limit;

  @ffi.Int64()
  external int memory_used_size;

  @ffi.Int64()
  external int malloc_count;

  @ffi.Int64()
  external int memory_used_count;

  @ffi.Int64()
  external int atom_count;

  @ffi.Int64()
  external int atom_size;

  @ffi.Int64()
  external int str_count;

  @ffi.Int64()
  external int str_size;

  @ffi.Int64()
  external int obj_count;

  @ffi.Int64()
  external int obj_size;

  @ffi.Int64()
  external int prop_count;

  @ffi.Int64()
  external int prop_size;

  @ffi.Int64()
  external int shape_count;

  @ffi.Int64()
  external int shape_size;

  @ffi.Int64()
  external int js_func_count;

  @ffi.Int64()
  external int js_func_size;

  @ffi.Int64()
  external int js_func_code_size;

  @ffi.Int64()
  external int js_func_pc2line_count;

  @ffi.Int64()
  external int js_func_pc2line_size;

  @ffi.Int64()
  external int c_func_count;

  @ffi.Int64()
  external int array_count;

  @ffi.Int64()
  external int fast_array_count;

  @ffi.Int64()
  external int fast_array_elements;

  @ffi.Int64()
  external int binary_object_count;

  @ffi.Int64()
  external int binary_object_size;
}

typedef FILE = _IO_FILE;

final class _IO_FILE extends ffi.Struct {
  @ffi.Int()
  external int _flags;

  external ffi.Pointer<ffi.Char> _IO_read_ptr;

  external ffi.Pointer<ffi.Char> _IO_read_end;

  external ffi.Pointer<ffi.Char> _IO_read_base;

  external ffi.Pointer<ffi.Char> _IO_write_base;

  external ffi.Pointer<ffi.Char> _IO_write_ptr;

  external ffi.Pointer<ffi.Char> _IO_write_end;

  external ffi.Pointer<ffi.Char> _IO_buf_base;

  external ffi.Pointer<ffi.Char> _IO_buf_end;

  external ffi.Pointer<ffi.Char> _IO_save_base;

  external ffi.Pointer<ffi.Char> _IO_backup_base;

  external ffi.Pointer<ffi.Char> _IO_save_end;

  external ffi.Pointer<_IO_marker> _markers;

  external ffi.Pointer<_IO_FILE> _chain;

  @ffi.Int()
  external int _fileno;

  @ffi.Int()
  external int _flags2;

  @__off_t()
  external int _old_offset;

  @ffi.UnsignedShort()
  external int _cur_column;

  @ffi.SignedChar()
  external int _vtable_offset;

  @ffi.Array.multi([1])
  external ffi.Array<ffi.Char> _shortbuf;

  external ffi.Pointer<_IO_lock_t> _lock;

  @__off64_t()
  external int _offset;

  external ffi.Pointer<_IO_codecvt> _codecvt;

  external ffi.Pointer<_IO_wide_data> _wide_data;

  external ffi.Pointer<_IO_FILE> _freeres_list;

  external ffi.Pointer<ffi.Void> _freeres_buf;

  @ffi.Size()
  external int __pad5;

  @ffi.Int()
  external int _mode;

  @ffi.Array.multi([20])
  external ffi.Array<ffi.Char> _unused2;
}

final class _IO_marker extends ffi.Opaque {}

typedef __off_t = ffi.Long;
typedef Dart__off_t = int;
typedef _IO_lock_t = ffi.Void;
typedef Dart_IO_lock_t = void;
typedef __off64_t = ffi.Long;
typedef Dart__off64_t = int;

final class _IO_codecvt extends ffi.Opaque {}

final class _IO_wide_data extends ffi.Opaque {}

typedef JSAtom = ffi.Uint32;
typedef DartJSAtom = int;

/// object class support
final class JSPropertyEnum extends ffi.Struct {
  @ffi.Int()
  external int is_enumerable;

  @JSAtom()
  external int atom;
}

final class JSPropertyDescriptor extends ffi.Struct {
  @ffi.Int()
  external int flags;

  external JSValue value;

  external JSValue getter;

  external JSValue setter;
}

final class JSClassExoticMethods extends ffi.Struct {
  /// Return -1 if exception (can only happen in case of Proxy object),
  /// FALSE if the property does not exists, TRUE if it exists. If 1 is
  /// returned, the property descriptor 'desc' is filled if != NULL.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<JSContext> ctx,
              ffi.Pointer<JSPropertyDescriptor> desc,
              JSValue obj,
              JSAtom prop)>> get_own_property;

  /// '*ptab' should hold the '*plen' property keys. Return 0 if OK,
  /// -1 if exception. The 'is_enumerable' field is ignored.
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<JSContext> ctx,
              ffi.Pointer<ffi.Pointer<JSPropertyEnum>> ptab,
              ffi.Pointer<ffi.Uint32> plen,
              JSValue obj)>> get_own_property_names;

  /// return < 0 if exception, or TRUE/FALSE
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<JSContext> ctx, JSValue obj, JSAtom prop)>>
      delete_property;

  /// return < 0 if exception or TRUE/FALSE
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<JSContext> ctx,
              JSValue this_obj,
              JSAtom prop,
              JSValue val,
              JSValue getter,
              JSValue setter,
              ffi.Int flags)>> define_own_property;

  /// The following methods can be emulated with the previous ones,
  /// so they are usually not needed */
  /// /* return < 0 if exception or TRUE/FALSE
  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<JSContext> ctx, JSValue obj, JSAtom atom)>>
      has_property;

  external ffi.Pointer<
      ffi.NativeFunction<
          JSValue Function(ffi.Pointer<JSContext> ctx, JSValue obj, JSAtom atom,
              JSValue receiver)>> get_property;

  /// return < 0 if exception or TRUE/FALSE
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<JSContext> ctx, JSValue obj, JSAtom atom,
              JSValue value, JSValue receiver, ffi.Int flags)>> set_property;
}

final class JSClassDef extends ffi.Struct {
  external ffi.Pointer<ffi.Char> class_name;

  external ffi.Pointer<JSClassFinalizer> finalizer;

  external ffi.Pointer<JSClassGCMark> gc_mark;

  /// if call != NULL, the object is a function. If (flags &
  /// JS_CALL_FLAG_CONSTRUCTOR) != 0, the function is called as a
  /// constructor. In this case, 'this_val' is new.target. A
  /// constructor call only happens if the object constructor bit is
  /// set (see JS_SetConstructorBit()).
  external ffi.Pointer<JSClassCall> call;

  /// XXX: suppress this indirection ? It is here only to save memory
  /// because only a few classes need these methods
  external ffi.Pointer<JSClassExoticMethods> exotic;
}

typedef JSClassFinalizer = ffi
    .NativeFunction<ffi.Void Function(ffi.Pointer<JSRuntime> rt, JSValue val)>;
typedef JSClassGCMark = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<JSRuntime> rt, JSValue val,
        ffi.Pointer<JS_MarkFunc> mark_func)>;
typedef JSClassCall = ffi.NativeFunction<
    JSValue Function(
        ffi.Pointer<JSContext> ctx,
        JSValue func_obj,
        JSValue this_val,
        ffi.Int argc,
        ffi.Pointer<JSValue> argv,
        ffi.Int flags)>;
typedef JSFreeArrayBufferDataFunc = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<JSRuntime> rt, ffi.Pointer<ffi.Void> opaque,
        ffi.Pointer<ffi.Void> ptr)>;

final class JSSharedArrayBufferFunctions extends ffi.Struct {
  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void> opaque, ffi.Size size)>> sab_alloc;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void> opaque, ffi.Pointer<ffi.Void> ptr)>>
      sab_free;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<ffi.Void> opaque, ffi.Pointer<ffi.Void> ptr)>>
      sab_dup;

  external ffi.Pointer<ffi.Void> sab_opaque;
}

abstract class JSPromiseStateEnum {
  static const int JS_PROMISE_PENDING = 0;
  static const int JS_PROMISE_FULFILLED = 1;
  static const int JS_PROMISE_REJECTED = 2;
}

/// is_handled = TRUE means that the rejection is handled
typedef JSHostPromiseRejectionTracker = ffi.NativeFunction<
    ffi.Void Function(ffi.Pointer<JSContext> ctx, JSValue promise,
        JSValue reason, ffi.Int is_handled, ffi.Pointer<ffi.Void> opaque)>;

/// return != 0 if the JS code needs to be interrupted
typedef JSInterruptHandler = ffi.NativeFunction<
    ffi.Int Function(ffi.Pointer<JSRuntime> rt, ffi.Pointer<ffi.Void> opaque)>;

final class JSModuleDef extends ffi.Opaque {}

/// return the module specifier (allocated with js_malloc()) or NULL if
/// exception
typedef JSModuleNormalizeFunc = ffi.NativeFunction<
    ffi.Pointer<ffi.Char> Function(
        ffi.Pointer<JSContext> ctx,
        ffi.Pointer<ffi.Char> module_base_name,
        ffi.Pointer<ffi.Char> module_name,
        ffi.Pointer<ffi.Void> opaque)>;
typedef JSModuleLoaderFunc = ffi.NativeFunction<
    ffi.Pointer<JSModuleDef> Function(ffi.Pointer<JSContext> ctx,
        ffi.Pointer<ffi.Char> module_name, ffi.Pointer<ffi.Void> opaque)>;

/// JS Job support
typedef JSJobFunc = ffi.NativeFunction<
    JSValue Function(
        ffi.Pointer<JSContext> ctx, ffi.Int argc, ffi.Pointer<JSValue> argv)>;

/// C function definition
abstract class JSCFunctionEnum {
  static const int JS_CFUNC_generic = 0;
  static const int JS_CFUNC_generic_magic = 1;
  static const int JS_CFUNC_constructor = 2;
  static const int JS_CFUNC_constructor_magic = 3;
  static const int JS_CFUNC_constructor_or_func = 4;
  static const int JS_CFUNC_constructor_or_func_magic = 5;
  static const int JS_CFUNC_f_f = 6;
  static const int JS_CFUNC_f_f_f = 7;
  static const int JS_CFUNC_getter = 8;
  static const int JS_CFUNC_setter = 9;
  static const int JS_CFUNC_getter_magic = 10;
  static const int JS_CFUNC_setter_magic = 11;
  static const int JS_CFUNC_iterator_next = 12;
}

final class JSCFunctionType extends ffi.Union {
  external ffi.Pointer<JSCFunction> generic;

  external ffi.Pointer<
      ffi.NativeFunction<
          JSValue Function(
              ffi.Pointer<JSContext> ctx,
              JSValue this_val,
              ffi.Int argc,
              ffi.Pointer<JSValue> argv,
              ffi.Int magic)>> generic_magic;

  external ffi.Pointer<JSCFunction> constructor;

  external ffi.Pointer<
      ffi.NativeFunction<
          JSValue Function(
              ffi.Pointer<JSContext> ctx,
              JSValue new_target,
              ffi.Int argc,
              ffi.Pointer<JSValue> argv,
              ffi.Int magic)>> constructor_magic;

  external ffi.Pointer<JSCFunction> constructor_or_func;

  external ffi.Pointer<ffi.NativeFunction<ffi.Double Function(ffi.Double)>> f_f;

  external ffi
      .Pointer<ffi.NativeFunction<ffi.Double Function(ffi.Double, ffi.Double)>>
      f_f_f;

  external ffi.Pointer<
          ffi.NativeFunction<
              JSValue Function(ffi.Pointer<JSContext> ctx, JSValue this_val)>>
      getter;

  external ffi.Pointer<
          ffi.NativeFunction<
              JSValue Function(
                  ffi.Pointer<JSContext> ctx, JSValue this_val, JSValue val)>>
      setter;

  external ffi.Pointer<
          ffi.NativeFunction<
              JSValue Function(
                  ffi.Pointer<JSContext> ctx, JSValue this_val, ffi.Int magic)>>
      getter_magic;

  external ffi.Pointer<
      ffi.NativeFunction<
          JSValue Function(ffi.Pointer<JSContext> ctx, JSValue this_val,
              JSValue val, ffi.Int magic)>> setter_magic;

  external ffi.Pointer<
      ffi.NativeFunction<
          JSValue Function(
              ffi.Pointer<JSContext> ctx,
              JSValue this_val,
              ffi.Int argc,
              ffi.Pointer<JSValue> argv,
              ffi.Pointer<ffi.Int> pdone,
              ffi.Int magic)>> iterator_next;
}

typedef JSCFunction = ffi.NativeFunction<
    JSValue Function(ffi.Pointer<JSContext> ctx, JSValue this_val, ffi.Int argc,
        ffi.Pointer<JSValue> argv)>;
typedef JSCFunctionData = ffi.NativeFunction<
    JSValue Function(
        ffi.Pointer<JSContext> ctx,
        JSValue this_val,
        ffi.Int argc,
        ffi.Pointer<JSValue> argv,
        ffi.Int magic,
        ffi.Pointer<JSValue> func_data)>;

/// C property definition
final class JSCFunctionListEntry extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  @ffi.Uint8()
  external int prop_flags;

  @ffi.Uint8()
  external int def_type;

  @ffi.Int16()
  external int magic;

  external UnnamedUnion1 u;
}

final class UnnamedUnion1 extends ffi.Union {
  external UnnamedStruct1 func;

  external UnnamedStruct2 getset;

  external UnnamedStruct3 alias;

  external UnnamedStruct4 prop_list;

  external ffi.Pointer<ffi.Char> str;

  @ffi.Int32()
  external int i32;

  @ffi.Int64()
  external int i64;

  @ffi.Double()
  external double f64;
}

final class UnnamedStruct1 extends ffi.Struct {
  /// XXX: should move outside union
  @ffi.Uint8()
  external int length;

  /// XXX: should move outside union
  @ffi.Uint8()
  external int cproto;

  external JSCFunctionType cfunc;
}

final class UnnamedStruct2 extends ffi.Struct {
  external JSCFunctionType get1;

  external JSCFunctionType set1;
}

final class UnnamedStruct3 extends ffi.Struct {
  external ffi.Pointer<ffi.Char> name;

  @ffi.Int()
  external int base;
}

final class UnnamedStruct4 extends ffi.Struct {
  external ffi.Pointer<JSCFunctionListEntry> tab;

  @ffi.Int()
  external int len;
}

/// C module definition
typedef JSModuleInitFunc = ffi.NativeFunction<
    ffi.Int Function(ffi.Pointer<JSContext> ctx, ffi.Pointer<JSModuleDef> m)>;

const int JS_TAG_FIRST = -11;

const int JS_TAG_BIG_DECIMAL = -11;

const int JS_TAG_BIG_INT = -10;

const int JS_TAG_BIG_FLOAT = -9;

const int JS_TAG_SYMBOL = -8;

const int JS_TAG_STRING = -7;

const int JS_TAG_MODULE = -3;

const int JS_TAG_FUNCTION_BYTECODE = -2;

const int JS_TAG_OBJECT = -1;

const int JS_TAG_INT = 0;

const int JS_TAG_BOOL = 1;

const int JS_TAG_NULL = 2;

const int JS_TAG_UNDEFINED = 3;

const int JS_TAG_UNINITIALIZED = 4;

const int JS_TAG_CATCH_OFFSET = 5;

const int JS_TAG_EXCEPTION = 6;

const int JS_TAG_FLOAT64 = 7;

const int JS_PROP_CONFIGURABLE = 1;

const int JS_PROP_WRITABLE = 2;

const int JS_PROP_ENUMERABLE = 4;

const int JS_PROP_C_W_E = 7;

const int JS_PROP_LENGTH = 8;

const int JS_PROP_TMASK = 48;

const int JS_PROP_NORMAL = 0;

const int JS_PROP_GETSET = 16;

const int JS_PROP_VARREF = 32;

const int JS_PROP_AUTOINIT = 48;

const int JS_PROP_HAS_SHIFT = 8;

const int JS_PROP_HAS_CONFIGURABLE = 256;

const int JS_PROP_HAS_WRITABLE = 512;

const int JS_PROP_HAS_ENUMERABLE = 1024;

const int JS_PROP_HAS_GET = 2048;

const int JS_PROP_HAS_SET = 4096;

const int JS_PROP_HAS_VALUE = 8192;

const int JS_PROP_THROW = 16384;

const int JS_PROP_THROW_STRICT = 32768;

const int JS_PROP_NO_ADD = 65536;

const int JS_PROP_NO_EXOTIC = 131072;

const int JS_DEFAULT_STACK_SIZE = 262144;

const int JS_EVAL_TYPE_GLOBAL = 0;

const int JS_EVAL_TYPE_MODULE = 1;

const int JS_EVAL_TYPE_DIRECT = 2;

const int JS_EVAL_TYPE_INDIRECT = 3;

const int JS_EVAL_TYPE_MASK = 3;

const int JS_EVAL_FLAG_STRICT = 8;

const int JS_EVAL_FLAG_STRIP = 16;

const int JS_EVAL_FLAG_COMPILE_ONLY = 32;

const int JS_EVAL_FLAG_BACKTRACE_BARRIER = 64;

const int JS_EVAL_FLAG_ASYNC = 128;

const int JS_ATOM_NULL = 0;

const int JS_CALL_FLAG_CONSTRUCTOR = 1;

const int JS_INVALID_CLASS_ID = 0;

const int JS_GPN_STRING_MASK = 1;

const int JS_GPN_SYMBOL_MASK = 2;

const int JS_GPN_PRIVATE_MASK = 4;

const int JS_GPN_ENUM_ONLY = 16;

const int JS_GPN_SET_ENUM = 32;

const int JS_PARSE_JSON_EXT = 1;

const int JS_WRITE_OBJ_BYTECODE = 1;

const int JS_WRITE_OBJ_BSWAP = 2;

const int JS_WRITE_OBJ_SAB = 4;

const int JS_WRITE_OBJ_REFERENCE = 8;

const int JS_READ_OBJ_BYTECODE = 1;

const int JS_READ_OBJ_ROM_DATA = 2;

const int JS_READ_OBJ_SAB = 4;

const int JS_READ_OBJ_REFERENCE = 8;

const int JS_DEF_CFUNC = 0;

const int JS_DEF_CGETSET = 1;

const int JS_DEF_CGETSET_MAGIC = 2;

const int JS_DEF_PROP_STRING = 3;

const int JS_DEF_PROP_INT32 = 4;

const int JS_DEF_PROP_INT64 = 5;

const int JS_DEF_PROP_DOUBLE = 6;

const int JS_DEF_PROP_UNDEFINED = 7;

const int JS_DEF_OBJECT = 8;

const int JS_DEF_ALIAS = 9;
